"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const typescript_1 = __importDefault(require("typescript"));
function findExportsWithNoValue(sourceFile) {
    const types = new Set();
    const values = new Set();
    const exported = {};
    function recordExport(name, { asType, asValue }) {
        const e = exported[name] || { asType: false, asValue: false };
        e.asType = e.asType || asType || false;
        e.asValue = e.asValue || asValue || false;
        exported[name] = e;
    }
    for (const statement of sourceFile.statements) {
        if (typescript_1.default.isTypeAliasDeclaration(statement) ||
            typescript_1.default.isInterfaceDeclaration(statement)) {
            const name = statement.name.text;
            types.add(name);
            if (hasExportModifier(statement)) {
                recordExport(name, { asType: true });
            }
        }
        else if (typescript_1.default.isVariableStatement(statement)) {
            for (const declaration of statement.declarationList.declarations) {
                if (typescript_1.default.isIdentifier(declaration.name)) {
                    const name = declaration.name.text;
                    values.add(name);
                    if (hasExportModifier(statement)) {
                        recordExport(name, { asValue: true });
                    }
                }
            }
        }
        else if (typescript_1.default.isFunctionDeclaration(statement)) {
            if (statement.name) {
                const name = statement.name.text;
                values.add(name);
                if (hasExportModifier(statement)) {
                    recordExport(name, { asValue: true });
                }
            }
        }
        else if (typescript_1.default.isClassDeclaration(statement) ||
            typescript_1.default.isEnumDeclaration(statement)) {
            if (statement.name) {
                const name = statement.name.text;
                types.add(name);
                values.add(name);
                if (hasExportModifier(statement)) {
                    recordExport(name, { asType: true, asValue: true });
                }
            }
        }
        else if (typescript_1.default.isExportDeclaration(statement) &&
            statement.exportClause &&
            !statement.moduleSpecifier &&
            typescript_1.default.isNamedExports(statement.exportClause)) {
            for (const element of statement.exportClause.elements) {
                const name = (element.propertyName || element.name).text;
                recordExport(name, { asType: true, asValue: !statement.isTypeOnly });
            }
        }
    }
    const exportsWithNoValue = new Set();
    for (const [name, e] of Object.entries(exported)) {
        if (!types.has(name)) {
            // No need for a fake value export if there is no type, because
            // nobody will import that as a type.
            continue;
        }
        if (e.asValue && values.has(name)) {
            // No need for a fake value export.
            continue;
        }
        exportsWithNoValue.add(name);
    }
    return [...exportsWithNoValue];
}
function hasExportModifier(node) {
    return (node.modifiers &&
        node.modifiers.findIndex((m) => m.kind === typescript_1.default.SyntaxKind.ExportKeyword) !==
            -1);
}
module.exports = function fakeExportedTypesPlugin(options = {}) {
    const readFile = options.readFile ||
        (async (id) => {
            try {
                return await fs_1.default.promises.readFile(id, "utf8");
            }
            catch {
                return null;
            }
        });
    return {
        name: "reactpreview-fake-exported-types",
        transform: async function (transformedCode, id) {
            const ext = path_1.default.extname(id);
            if (ext.startsWith(".js")) {
                return;
            }
            const fileContent = await readFile(id);
            if (fileContent === null) {
                return;
            }
            const isJSX = ext.endsWith("x");
            const sourceFile = typescript_1.default.createSourceFile(id, fileContent, typescript_1.default.ScriptTarget.Latest, false, isJSX ? typescript_1.default.ScriptKind.TSX : typescript_1.default.ScriptKind.TS);
            return `${transformedCode}
const __fakeValueExport__ = null;
export { ${findExportsWithNoValue(sourceFile)
                .map((e) => `__fakeValueExport__ as ${e}`)
                .join(", ")} };`;
        },
    };
};
